/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  9
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    format      ascii;
    class       volScalarField;
    object      fluidPhase_E1;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

dimensions      [0 -3 0 0 1 0 0];

internalField   uniform 0;

boundaryField
{
    inletVessel
    {
        type            zeroGradient;
    }
    
    outletVessel
    {
        type            zeroGradient;
    }

    fixedWalls
    {
        type            zeroGradient;
    }
    
    injuryWalls
    {
        type            codedFixedValue;
        value           uniform 0.0;
        name            robinBC_E1;

        code
        #{
            /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
            Robin BC of form:
                 -D d/dn(field) = K * field + F

            The first order discretization is:
                -D * (field_f - field_c) / dn = K * field_f + F.
            
            Solving for field_f provides:
                field_f = \Delta * D / (\Delta * D + K) * field_c 
                          - 1 / (\Delta * D + K) * F, 
            where 
                field_f = the value on the face,
                field_c = the value at the cell center
                \Delta = 1/dn = deltaCoeffs (in OpenFOAM)
            Note that the deltaCoeffs are always positive, which doesn't take
            into account the direction of the vector from the cell center to 
            the cell face.  Therefore, we define 
                DeltaI = vector(\Delta, \Delta, 0) & nf
            for 2d orthogonal meshes.  The & is the dot product, and nf is the 
            face-normal vector.
            \* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
            
            // Reference to this field on face (f) and center (c)
            scalarField& field_f = *this;
            const tmp<scalarField> field_c = patchInternalField();

            // Lookup diffusion rate and kinetic rates 
            const scalar Dc = readScalar
            (
                db().lookupObject<IOdictionary>
                (
                    "inputParameters"
                ).lookup("Dc")
            );
            
            const scalar Kc0_cat = readScalar
            (
                db().lookupObject<IOdictionary>
                (
                    "inputParameters"
                ).lookup("Kc0_cat")
            );

            // Lookup necessary fields for reaction at boundary
            const scalarField& C0
            (
                patch().lookupPatchField<volScalarField, scalar>("seBound_C0")
            );

            // Get the direction of the deltaCoeffs
            const vectorField deltaVec = patch().delta();

            // Loop for all faces on within this patch            
            forAll(field_f, faceI)
            {
                // !!!! Edit these values !!!!
                scalar K = 0;
                scalar F = Kc0_cat * C0[faceI];

                // !!!! Don't edit below this line !!!!
                // ---------------------------------------------------------------
                
                // Get deltaCoeffs (note always positive) 
                // must adjust sign with normalized delta vector 
                // (only works for orthogonal mesh)
                scalar DeltaI = this->patch().deltaCoeffs()[faceI];
                DeltaI = vector(DeltaI,DeltaI,DeltaI) & deltaVec[faceI] / mag(deltaVec[faceI]);
                
                scalar denom = Dc * DeltaI + K;
                
                // Value at boundary 
                field_f[faceI] =  DeltaI * Dc / denom * field_c.ref()[faceI]
                                  - 1.0/denom * F;

            }
            
        #};

    }
    
    frontAndBack
    {
        type            empty;
    }
}

// ************************************************************************* //
